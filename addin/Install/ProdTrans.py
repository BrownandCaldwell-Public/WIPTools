# ---------------------------------------------------------------------------
# TSSProd.py
# Created on: Fri Feb 16 2007 10:08:02 AM
#   (generated by ArcGIS/ModelBuilder)
# ---------------------------------------------------------------------------

# Import system modules
import sys, string, os
import Helper
import regression
import arcpy
from arcpy import env
arcpy.env.extent = "MAXOF"
from arcpy.sa import *

hp = Helper.Helper(sys.argv)
try:
    
    # Script arguments...
    StrInvPts_preclip = sys.argv[1]
    RB_Ero = sys.argv[2]
    RB_Hgt = sys.argv[3]
    RB_Len = sys.argv[4]
    LB_Ero = sys.argv[5]
    LB_Hgt = sys.argv[6]
    LB_Len = sys.argv[7]
    Streams_nd = os.path.join(hp.Workspace + "\\WIPoutput.mdb", "streams")
    streams = hp.RemoveNulls(Streams_nd)
    
    cumda = Raster(os.path.join(hp.Workspace + "\\WIPoutput.mdb", "cumda"))
    
    
    flowdir = os.path.join(hp.Workspace + "\\WIPoutput.mdb", "flowdir")* hp.Mask 
    flowdir.save(os.path.join(hp.SWorkspace, "flowdir")) 
        
    vecmask = os.path.join(hp.SWorkspace, "vecmask.shp")
    
    arcpy.RasterToPolygon_conversion(hp.Mask, vecmask, "SIMPLIFY", "Value")
    
    StrInvPts = os.path.join(hp.SWorkspace, "StrInvPts.shp")
    arcpy.Clip_analysis(StrInvPts_preclip, vecmask, StrInvPts)
    count = int(arcpy.GetCount_management(StrInvPts).getOutput(0))
    if count < 1:
        raise Exception, "No stream inventory points in the study area"
    
    hp.log("Reclassify flowdirection to find straight paths...")
    Flowdirs = Reclassify(flowdir, "VALUE", "1 1;2 0;4 1;8 0;16 1;32 0;64 1;128 0", "DATA")
    
    hp.log("Reclassify flowdirection to find diagonal paths...")
    Flowdird = Reclassify(flowdir, "VALUE", "1 0;2 1;4 0;8 1;16 0;32 1;64 0;128 1", "DATA")
    
    hp.log("Calculate distance grid...")
    Dist = (Flowdirs + Flowdird * 1.4142)* hp.units['size']
    Dist.save(os.path.join(hp.SWorkspace, "dist"))

    n_channel = sys.argv[8]
    BankWidth = sys.argv[9]
    BankDepth = sys.argv[10]
    BankHt = os.path.join(hp.SWorkspace, "BankHt")
    
    n_default = float(sys.argv[11])
    BankHydCoe = float(sys.argv[12])
    BankHydExp = float(sys.argv[13])
    defEro = float(sys.argv[14])
    
    LU_existing_file = sys.argv[15].strip()
    LU_existing_fld = sys.argv[16].strip()
    LU_future_file = sys.argv[17].strip()
    LU_future_fld = sys.argv[18].strip()
    
    slope = sys.argv[19]
    pointsources = sys.argv[20]
   
    
    params = {}
    exec(sys.argv[21])
    if not params:
        hp.log("   \nThere are no parameters selected to calculate production for!!")
        raise Exception
        
    Landuses = []
    if LU_existing_file != "":
        Landuses.append( ( LU_existing_file, LU_existing_fld, "E" ) )
    if LU_future_file != "":
        Landuses.append( ( LU_future_file, LU_future_fld, "F" ) )
    if Landuses == []:   
        hp.log("   \nThere are no parameters selected to calculate production for!!")
        raise Exception
    
    for LU in Landuses:
        hp.log("Join LUT to landuse layer")
        arcpy.MakeFeatureLayer_management(LU[0], "LULyr")
        
        input = file(os.path.join(hp.AppPath, r"..\Tooldata\LUT.csv"), 'r')
        output = file(os.path.join(hp.SWorkspace, "LUT.txt"), 'w')
        output.write(input.read().replace(",", "\t"))
        input.close()
        output.close()
        
        arcpy.MakeTableView_management(os.path.join(hp.SWorkspace, "LUT.txt"), "LUTview")
        arcpy.AddJoin_management("LULyr" , LU[1], "LUTview", "TABLE_MATC")

        
        hp.log("Create Export Coefficient (washoff rate) rasters")
        for param in params:
            pn = param[:10].strip()
            hp.log( '  Parameter: ' + param)
            arcpy.PolygonToRaster_conversion("LULyr", param, os.path.join(hp.SWorkspace,"temp"), "MAXIMUM_AREA", param, hp.units['size'])
            lu2temp = Raster(os.path.join(hp.SWorkspace,"temp")) * float(hp.units['cellsqft']/43560)
            hp.saveRasterOutput(lu2temp, LU[2] + pn) ######################
    
    hp.log("Create roughness grid")
    arcpy.PolygonToRaster_conversion("LULyr", 'MANNINGSN', os.path.join(hp.SWorkspace,"MANNINGSN"), "MAXIMUM_AREA", 'MANNINGSN', hp.units['size'])
    
    hp.log("Calculate overland flow velocity")
    MANNINGSN = Raster(os.path.join(hp.SWorkspace,"MANNINGSN"))
    UplandVel = MANNINGSN * Power(slope, 0.5 )
    
    hp.log("Calculate overland flow detention time")
    Detovrlndt = Dist / UplandVel
    Detovrlnd = hp.RemoveNulls(Detovrlndt)
    Detovrlnd.save(os.path.join(hp.SWorkspace, "detovrlnd"))
    
    hp.log("Calculate Hydraulic geometry...")
    BankHt = Power(cumda, BankHydExp) * BankHydCoe
    
    
    fields = [RB_Ero, RB_Hgt, RB_Len, LB_Ero, LB_Hgt, LB_Len,n_channel, BankWidth, BankDepth]
    for field in fields:
        
        hp.log("Stream Assessment points to raster...")
        
        #~ ras = os.path.join(hp.SWorkspace, field.replace("_","") + "ras")
        #~ extract = field+"e"
        #~ asc = os.path.join(hp.SWorkspace, field+"ras.asc")
        
        f = os.path.join(hp.SWorkspace, "f" + field)
        arcpy.FeatureToRaster_conversion(StrInvPts, field, f, flowdir)
        ras = Raster(f)
        AttributeRaster = Float(ras) * hp.Mask
        
        hp.log("Extract %s attribute..." % field)
        if field == RB_Len or field == LB_Len:
            Units = hp.units['size']
        else: 
            Units = None
        
        extract = hp.AttExtract(AttributeRaster, flowdir, field+"e", streams, Units)
        
        if field == RB_Len or field == LB_Len:
            hp.log("Reclassify Bank length attribute...")
            #~ rrange = RemapRange([[-10000000000,0,0], [0.00001,1000000000000,1]]) # this does not work 
            reclass = Reclassify(extract, "Value", ".00001 100000 1;-100000 0 0; NoData 0", "DATA")
            #~ reclass = hp.RemoveNulls(reclass_step1)
            reclass.save(os.path.join(hp.SWorkspace, field + "rc"))
    
    
    for LU in Landuses:
        for p in params:
            pn = p[:10].strip()
            ps_field = params[p]['PntSrc']
            defProd = params[p]['DefEro']
            
            hp.log("  " + pn)
            hp.log("Calculate Right bank stream production...")
            RBL = Raster(os.path.join(hp.SWorkspace, RB_Len+"rc"))
            RBHT = Raster(os.path.join(hp.SWorkspace, RB_Hgt+"e"))
            RBE = Raster(os.path.join(hp.SWorkspace, RB_Ero+"e"))
            rt = RBL * streams * defProd * RBHT * RBE / 100 
            rt.save(os.path.join(hp.SWorkspace, "rt"+pn))
            RB = hp.RemoveNulls(rt) 
            RB.save(os.path.join(hp.SWorkspace, "rb"+pn))

            
            hp.log("Calculate Left bank stream production...")
            LBL = Raster(os.path.join(hp.SWorkspace,LB_Len+"rc"))
            LBHT = Raster(os.path.join(hp.SWorkspace, LB_Hgt+"e"))
            LBE = Raster(os.path.join(hp.SWorkspace, LB_Ero+"e"))
            lt = LBL * streams * defProd * LBHT* LBE/ 100
            lt.save(os.path.join(hp.SWorkspace, "lt"+pn))
            LB = hp.RemoveNulls(lt) 
            LB.save(os.path.join(hp.SWorkspace, "lb"+pn))
            
            hp.log("Calculate remaining stream production...")
            B = streams * BankHt * defProd * defEro / 100
            B.save(os.path.join(hp.SWorkspace, "B"+pn))
            
            hp.log("Combine Stream production...")
            APPF = ( BooleanNot(RB) * B + RB ) + ( BooleanNot(LB) * B + LB )
            APPF.save(os.path.join(hp.SWorkspace, "appf"))
            
            lakes = Raster(os.path.join(hp.Workspace + "\\WIPoutput.mdb", "lakes"))
            hp.log("Calculate APPS production...")
            APPS = APPF * Dist * BooleanNot(lakes)
            APPS.save(os.path.join(hp.SWorkspace, "apps"))
            
            Impervious_Cover = Raster(os.path.join(hp.Workspace + "\\WIPoutput.mdb", "impcov"))
            hp.log("Combining washoff rate and stream production...")
            PStream = APPS * BooleanNot(Impervious_Cover)
            
            impcovrc = Reclassify(Impervious_Cover, "Value", "NoData 0;-10000000 0 0;0.00001 1000000 1", "DATA")
            
            
            LU2 =  Raster(os.path.join(hp.Workspace + "\\WIPoutput.mdb", LU[2]+pn))
            Ptemp = PStream + LU2 * impcovrc * streams
            Ptemp.save(os.path.join(hp.SWorkspace, "ptemp"))
            PStream.save(os.path.join(hp.SWorkspace, "pstream"))
            streams.save(os.path.join(hp.SWorkspace, "streams"))
            impcovrc.save(os.path.join(hp.SWorkspace, "impcovrc"))
            
            production = Ptemp + LU2 * BooleanNot(streams)
            hp.saveRasterOutput(production, "P" + LU[2] + pn)
            
    
    hp.log("Determine stream roughness")
    n_channele1 = Raster(os.path.join(hp.SWorkspace, n_channel+ "e") )
    n_channele = hp.RemoveNulls(n_channele1)
    n_channele.save(os.path.join(hp.SWorkspace, "n_channele"))
    
    nstream = streams * BooleanNot(n_channele)* n_default + n_channele
    nstream.save(os.path.join(hp.SWorkspace, "nstream"))

    
    hp.log("Calculate Hydraulic Radius")
    rb_Lenrc = Raster(os.path.join(hp.SWorkspace, RB_Len+"rc") )
    lb_Lenrc = Raster(os.path.join(hp.SWorkspace, LB_Len+"rc") )
    
    # create stream segment mask where data exists 
    #~ rbgreater = GreaterThan(rb_Lenrc, lb_Lenrc)
    #~ rbgreater.save(os.path.join(hp.SWorkspace, "rbgreater"))
    #~ rbgreater1 = rbgreater * rb_Lenrc
    #~ rbgreater1.save(os.path.join(hp.SWorkspace, "rbgreater1"))
    #~ lbgreater = GreaterThan(lb_Lenrc, rb_Lenrc)
    #~ lbgreater.save(os.path.join(hp.SWorkspace, "lbgreater"))
    #~ lbgreater1 = lbgreater * lb_Lenrc
    #~ lbgreater1.save(os.path.join(hp.SWorkspace, "lbgreater1"))
    #~ totalgt = rbgreater1 +lbgreater1
    #~ totalgt.save(os.path.join(hp.SWorkspace, "totalgt"))
    #~ dataclip = streams * totalgt
    
    dataclip = streams * CellStatistics([rb_Lenrc, lb_Lenrc], "MAXIMUM", "DATA")
    dataclip.save(os.path.join(hp.SWorkspace, "dataclip"))
    
    # fill in bank width where values are missing along stream
    widthdef = 20.9 * Power ( ( Float(cumda) / 640 ), 0.376 )
    BankWidthe = Raster(os.path.join(hp.SWorkspace, BankWidth+"e") )
    widthtemp = dataclip * BankWidthe
    widthtemp.save(os.path.join(hp.SWorkspace, "widthtemp")) 
    width = streams * BooleanNot(widthtemp) * widthdef + widthtemp
    width.save(os.path.join(hp.SWorkspace, "width"))

    
    # fill in bank depth where values are missing along stream
    depthdef = 3.02 * Power ( ( Float(cumda) / 640 ), 0.258 )
    BankDepthe = Raster(os.path.join(hp.SWorkspace, BankDepth+ "e") )
    depthtemp = dataclip * BankDepthe
    depth = streams * BooleanNot(depthtemp) * depthdef + depthtemp
    depth.save(os.path.join(hp.SWorkspace, "depth"))

    
    hydradiusC = (Float(width) * Float(depth)) / (Float(width) + 2 * Float(depth))
    hydradiusC.save(os.path.join(hp.SWorkspace, "hydradiusC"))
    hydradius = hp.RemoveNulls(hydradiusC)
    hydradius.save(os.path.join(hp.SWorkspace, "hydradius"))
    
    hp.log("Calculate normal stream velocity")
    tempvel = Power (hydradius, 0.6667) *  Power (Float(slope), 0.5) / nstream
    tempvel.save(os.path.join(hp.SWorkspace, "tempvel"))
    
    streamvel = hp.RemoveNulls(tempvel)
    streamvel.save(os.path.join(hp.SWorkspace, "streamvel"))
        
    hp.log("Calculate in-stream flow detention time")
    Detstreamt = Dist / streamvel
    Detstream = hp.RemoveNulls(Detstreamt)
    Detstream.save(os.path.join(hp.SWorkspace, "detstream"))
    
    hp.log("Calculate total flow detention time")
    Dettime =  Detstream + Detovrlnd * BooleanNot (Detstream)  
    Dettime.save(os.path.join(hp.SWorkspace, "dettime"))    
            
    Cumulative_Impervious = Raster(os.path.join(hp.Workspace + "\\WIPoutput.mdb", "cumimpcovlake"))
##    usgs_calcs = Helper.USGSVars(hp.Basin)
    urbanQcp = regression.urbanQcp(hp.Basin, cumda, Cumulative_Impervious)
    hp.saveRasterOutput(urbanQcp, "UrbanQ1")
    
    hp.log("Calculate Urban/Rural ratio...")
    Rural_1yrQ = Raster(os.path.join(hp.Workspace + "\\WIPoutput.mdb","UndevQ"))
    
    URratio = urbanQcp / Rural_1yrQ
    hp.saveRasterOutput(URratio, "urbrurratio")
    
    hp.log("Clip to streams...")
    # and round
    URratiocl = Int( RoundUp( RoundDown( Streams_nd* URratio * 20000 ) / 2))
    
    hp.log("Vectorize...")
    
    URRatio_Vector = os.path.join(hp.SWorkspace, "urratiovec.shp")
    StreamToFeature(URratiocl, flowdir, URRatio_Vector, "NO_SIMPLIFY") 
    hp.ConvertGRIDCODEatt(URRatio_Vector)
    arcpy.CopyFeatures_management(os.path.join(hp.SWorkspace, "urratiovec.shp"), os.path.join(hp.Workspace + "\\WIPoutput.mdb", "urratiovec"))
    hp.models[hp.current_tool]["output"].append(os.path.join(hp.Workspace + "\\WIPoutput.mdb", "urratiovec"))
    
    for LU in Landuses:
        for p in params:
            pn = p[:10].strip()
            output = os.path.join(hp.Workspace + "\\WIPoutput.mdb", "q" + LU[2] + pn)
            defProd = params[p]['DefEro']
            production = os.path.join(hp.Workspace + "\\WIPoutput.mdb", "P" + LU[2] + pn)    
            
            pointsrc = ""
            if params[p]['PntSrc']:
                hp.log("Create point source input raster")
                
                pointsrcshp = os.path.join(hp.SWorkspace, "pointsrc.shp")
                arcpy.Clip_analysis(pointsources, vecmask, pointsrcshp)
                
                count = int(arcpy.GetCount_management(pointsrcshp).getOutput(0))
                if count > 0:
                    hp.log("  found %i points source inputs in study area" % count)
                    temppt = hp.GetTempRasterPath("temppt")
                    arcpy.FeatureToRaster_conversion(pointsrcshp, params[p]['PntSrc'], temppt, cumda)
                    
                    pointsrc = hp.RemoveNulls(temppt)
                    hp.saveRasterOutput(pointsrc, "pt" + LU[2]+pn)
            
            hp.log("Add erosivity and point sources to %s production..." % (LU[2]+pn))
            data_ero = Helper.CalcErosivity(hp, defProd, production, pointsrc, URratio, streams)
            arcpy.CopyRaster_management(data_ero, output)
            
            if params[p]['K']:
                K = Exp( params[p]['K'] * Dettime / -86400) 
                hp.saveRasterOutput(K, 'K'+LU[2]+pn)
    
    hp.Close()
    
except:       
    i, j, k = sys.exc_info()
    hp.EH(i, j, k)
